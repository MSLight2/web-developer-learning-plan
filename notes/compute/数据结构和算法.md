### 数据结构和算法入门
- 什么是数据结构和算法
  从广义上讲，**数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。**
- 为什么总是把数据结构和算法放到一起
  应为数据结构和算法是相辅相成的，**数据结构是为算法服务的，算法是作用在特定的数据结构之上的。**
- 数据结构学习重点
  **首先要掌握一个数据结构与算法中最重要的概念——复杂度分析（这个是最重要的）**。这是衡量一个数据结构和算法是否合适，是否达到要求，是否完美，是否需要优化的标准
- 20个最常用的数据结构和算法，需逐一攻克
  - 10 个数据结构：`数组`、`链表`、`栈`、`队列`、`散列表`、`二叉树`、`堆`、`跳表`、`图`、`Trie 树`；
  - 10 个算法：`递归`、`排序`、`二分查找`、`搜索`、`哈希算法`、`贪心算法`、`分治算法`、`回溯算法`、`动态规划`、`字符串匹配算法`
- 学习算法不要死记硬背，**要学习它的"来历""自身的特点""适合解决的问题"以及"实际的应用场景"**；就像学数学一样，理解为主，不同环境选择最合适的公式。
- 学习算法一定要
  - 边学边练，练习很重要。适度刷题。
  - 多问，思考
  - 还有就是坚持！

### 算法时间空间复杂度分析
1. 只关注循环执行次数最多的一段代码
    - 大 O 这种复杂度表示方法只是表示一种变化趋势，我们通常会忽略掉公式中的`常量`、`低阶`、`系数`，`只需要记录一个最大阶的量级就可以了`。所以，**我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
    - 总的时间复杂度就等于量级最大的那段代码的时间复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 几种常见时间复杂度实例分析
- 常见的复杂度量级

|多项式量级|非多项式量级|
|----------|-----------|
|常量阶O(1)|增速阶O(2<sup>n</sup>)|
|线性阶O(n)|阶乘阶O(n!)|
|对数阶O(logn)||
|线性对数阶O(nlogn)||
|平方阶O(n<sup>2</sup>)、立方阶O(n<sup>3</sup>)...K次方阶O(n<sup>k</sup>)||

罗列的复杂度量级，我们可以粗略地分为两类，`多项式量级`和非`多项式量级`。其中，非多项式量级只有两个。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。**所以，非多项式时间复杂度的算法其实是非常低效的算法**。

- O(1)
    - O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码
    - 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)
- O(logn)、O(nlogn)
    ```java
    i=1;
    while (i <= n) {
      i = i * 2;
    }
    ```
    - 在采用大 O 标记复杂度的时候，可以忽略系数，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的"底"，统一表示为 O(logn)
    - 如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而
     且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)
- O(m+n)、O(m*n)
    - `由两个数据的规模`来决定；假如m 和 n 是表示两个数据规模，我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)
    - 乘法法则继续有效

#### 空间复杂度分析
复杂度的全称是`渐进时间复杂度`，`表示算法的执行时间与数据规模之间的增长关系`。类比一下，空间复杂度全称就是`渐进空间复杂度`（asymptotic space complexity），`表示算法的存储空间与数据规模之间的增长关系`。

我们常见的空间复杂度就是 O(1)、O(n)、O(n<sup>2</sup>)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

#### 浅析最好、最坏、平均、均摊时间复杂度
- 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度
- 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度
- 平均情况时间复杂度（平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度）、
  -最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，就需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度
- 均摊时间复杂度
  - `摊还分析法`，通过摊还分析得到的时间复杂度我们起了一个名字，叫`均摊时间复杂度`
  - 应用场景:
    - 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度
  - **均摊时间复杂度就是一种特殊的平均时间复杂度**