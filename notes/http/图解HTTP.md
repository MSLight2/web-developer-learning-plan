### TCP/IP
>TCP/IP 是互联网相关的各类协议族的总称
- **TCP/IP 协议族按层次分别分为以下 4 层**：
  - 应用层、传输层、网络层和数据链路层
- 应用层
  - 应用层决定了向用户提供应用服务时通信的活动
  - TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP、DNS、HTTP
- 传输层
  - 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输
  - 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）
- 网络层（又名网络互连层）
  - 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位
  - 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线
- 链路层（又名数据链路层，网络接口层）
  - 用来处理连接网络的硬件部分。硬件上的范畴均在链路层的作用范围之内
- **TCP三次握手**
  - 用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达
  - 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和ACK（acknowledgement）（同步和确认标志）
    - 发送端首先发送一个带 SYN 标志的数据包给对方。
    - 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。
    - 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束
- **TCP四次挥手**
- **URI和URL**
   -  URI：统一资源标识符，URL：统一资源定位符；URL是URI的子集
   -  RFC标准：协议方案名://登录信息/服务器地址(ip/域名)/带层次的文件路径/查询字符串/片段标识符(#/,可选)
### HTTP使用方法
- **GET** ：获取资源
- **POST**：传输实体主体
- **PUT**：传输文件
  - 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。
- **HEAD**：获得报文首部
  - HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。
- **DELETE**：删除文件
  - DELETE 方法用来删除文件，是与 PUT 相反的方法
- **OPTIONS**：询问支持的方法
- **TRACE**：追踪路径
  - 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输
  - TRACE 方法本来就不怎么常用，再加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。
- **CONNECT**：要求用隧道协议连接代理
  - CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。
### HTTP报文
- **HTTP报文构成**
  1. 请求行/响应行
     - 请求方法 URL HTTP版本(GET /index.html HTTP1.1)/ 响应转态吗 原因短语 HTTP版本(200 ok HTTP1.1)
  2. 请求头/响应头
     - 一般有4种首部（通用首部、请求首部、响应首部和实体首部）
  3. 请求实体/响应实体 → 也叫报文主体
- **报文主体和实体主体的差异**
  - 报文
    - 是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输
  - 实体
    - 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成
  - HTTP 报文的主体用于传输请求或响应的实体主体
  - 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异
- **压缩传输的内容编码**
  - 内容编码指明应用在实体内容上的编码格式
  - 常用的内容编码有：
    - gzip（GNU zip）
    - compress（UNIX 系统的标准压缩）
    - deflate（zlib）
    - identity（不进行编码
### 返回结果的 HTTP 状态码

|  |类别     |原因短语  |
|---------|---------|---------|
|1XX     |信息性状态码       |接收的请求正在处理       |
|2XX     |成功状态码         |请求正常处理完毕         |
|3XX     |重定向状态码       |需要进行附加操作以完成请求|
|4XX     |客户端错误状态码   |服务器无法处理请求        |
|5XX     |服务器错误状态码   | 服务器处理请求出错       |

- **常用的14种状态码**
  - 200 OK：表示从客户端发来的请求在服务器端被正常处理了
  - 204 No Content：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
  - 206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求
  - 301 Moved Permanently：永久性重定向
  - 302 Found：临时性重定向
  - 303 See Other：和 302 状态码有着相同的功能
    - 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源
    - 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别
    - >当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。
    - > 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做
  - 304 Not Modified：
    - 该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。
    - 304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。
    - >2 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部
    - > 这个一般指服务端缓存
  - 307 Temporary Redirect：临时重定向
    - 尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。
    - 307 会遵照浏览器标准，不会从 POST 变成 GET。
  - 400 Bad Request：表示请求报文中存在语法错误
  - 401 Unauthorized：表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息
    - 若之前已进行过 1 次请求，则表示用 户认证失败
  - 403 Forbidden：表明对请求资源的访问被服务器拒绝了
  - 404 Not Found：表明服务器上无法找到请求的资源
  - 500 Internal Server Error：表明服务器端在执行请求时发生了错误
  - 503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
### HTTP首部
- **通用首部字段**

|首部字段名          |说明  |
|-------------------|---------|
|Cache-Control      | 控制缓存的行为 |
|Connection         | 逐跳首部、连接的管理 |
|Date               | 创建报文的日期时间 |
|Pragma             | 报文指令 |
|Trailer            | 报文末端的首部一览 |
|Transfer-Encoding  | 指定报文主体的传输编码方式 |
|Upgrade            | 升级为其他协议 |
|Via                | 代理服务器的相关信息 |
|Warning            | 错误通知 |

- **请求首部字段**

|首部字段名  |说明  |
|---------------------|---------|
|Accept               | 用户代理可处理的媒体类型 |
|Accept-Charset       | 优先的字符集 |
|Accept-Encoding      | 优先的内容编码 |
|Accept-Language      | 优先的语言（自然语言） |
|Authorization        | Web认证信息 |
|Expect               | 期待服务器的特定行为 |
|From                 | 用户的电子邮箱地址 |
|Host                 | 请求资源所在服务器 |
|If-Match             | 比较实体标记（ETag） |
|If-Modified-Since    | 比较资源的更新时间 |
|If-None-Match        | 比较实体标记（与 If-Match 相反） |
|If-Range             | 资源未更新时发送实体 Byte 的范围请求 |
|If-Unmodified-Since  | 比较资源的更新时间（与If-Modified-Since相反） |
|Max-Forwards         | 最大传输逐跳数 |
|Proxy-Authorization  | 代理服务器要求客户端的认证信息 |
|Range                | 实体的字节范围请求 |
|Referer              | 对请求中 URI 的原始获取方 |
|TE                   | 传输编码的优先级 |
|User-Agent           | HTTP 客户端程序的信息 |

- **响应首部字段**

|首部字段名  |说明  |
|-------------------|---------|
|Accept-Ranges      | 是否接受字节范围请求|
|Age                | 推算资源创建经过时间 |
|ETag               | 资源的匹配信息 |
|Location           | 令客户端重定向至指定URI |
|Proxy-Authenticate | 代理服务器对客户端的认证信息 |
|Retry-After        | 对再次发起请求的时机要求 |
|Server             | HTTP服务器的安装信息 |
|Vary               | 代理服务器缓存的管理信息 |
|WWW-Authenticate   | 服务器对客户端的认证信息 |

- **实体首部字段**

|首部字段名  |说明  |
|-----------------|---------|
|Allow            | 资源可支持的HTTP方法 |
|Content-Encoding | 实体主体适用的编码方式 |
|Content-Language | 实体主体的自然语言 |
|Content-Length   | 实体主体的大小（单位：字节） |
|Content-Location | 替代对应资源的URI |
|Content-MD5      | 实体主体的报文摘要 |
|Content-Range    | 实体主体的位置范围 |
|Content-Type     | 实体主体的媒体类型 |
|Expires          | 实体主体过期的日期时间 |
|Last-Modified    | 资源的最后修改日期时间 |

**Cache-Control**
- **缓存请求指令**

|指令| 参数| 说明|
|---|------|-----|
|no-cache             | 无    | 强制向源服务器再次验证|
|no-store             | 无    | 不缓存请求或响应的任何内容|
|max-age = [ 秒]      | 必需   | 响应的最大Age值|
|max-stale( = [ 秒])  | 可省略 | 接收已过期的响应|
|min-fresh = [ 秒]    | 必需   | 期望在指定时间内的响应仍有效|
|no-transform         | 无    | 代理不可更改媒体类型|
|only-if-cached       | 无    | 从缓存获取资源|
|cache-extension      | -     | 新指令标记（token）|

- **缓存响应指令**

|指令 |参数| 说明|
|---|------|-----|
|public           | 无    | 可向任意方提供响应的缓存|
|private          | 可省略 | 仅向特定用户返回响应|
|no-cache         | 可省略 | 缓存前必须先确认其有效性|
|no-store         | 无    | 不缓存请求或响应的任何内容|
|no-transform     | 无    | 代理不可更改媒体类型|
|must-revalidate  | 无    | 可缓存但必须再向源服务器进行确认|
|proxy-revalidate | 无    |要求中间缓存服务器对缓存的响应有效性再进行确认|
|max-age = [ 秒]  | 必需   | 响应的最大Age值|
|s-maxage = [ 秒] | 必需   | 公共缓存服务器响应的最大Age值|
|cache-extension  | -     | 新指令标记（token）|

### 确保web安全的HTTPS
- **HTTP的缺点**
  - HTTP是明文传输，内容容易被窃取。
  - HTTP无法进行身份认证，容易被伪装
  - HTTP不能确认报文的完整性，不能判断报文是否被串改
- **什么是HTTPS**
  - 就是HTTP+加密+认证+完整性保护。
  - HTTPS是身披SSL外壳的HTTP。
- **HTTPS采用的是混合加密模式**
  - 数据传输使用的共享秘钥加密（对称加密），传输对称加密共享秘钥时使用的是公开秘钥加密（非对称加密）
  - 因为非对称加密比对称加密处理要更为复杂，处理速度要慢所以在保证安全的前提下使用对称加密传输数据
  - 由于要证明公开秘钥本身是可信任，货真价实的秘钥，所以引入了数字证书认证机构
- **数字证书认证机构的业务流程**
  - 首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起
  - 服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书
  - 接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的
  - 考虑到公开秘钥传输的安全性，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。
- **HTTPS 的安全通信机制**
  1. 客户端通过发送报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件列表
  2. 服务器可进行 SSL 通信时，服务端会根据客户端的加密组件类表，以及本身支持的加密列表筛选出共同支持的加密组件列表发送至客户端
  3. 之后服务端会发送包含公开秘钥证书的报文
  4. 最后服务器通知客户端SSL协商结束
  5. SSL协商结束后，客户端会使用公开秘钥证书中的公开秘钥对服务器进行验证，验证通过后，会使用公开秘钥加密对称加密生成的共享秘钥，最后把加密的共享秘钥已经经过对称加密的报文发送给服务端。
  6. 之后会在发送报文，提示服务器以后通信用这个共享秘钥
  7. 客户端发送结束报文。此次握手协商是否成功，要取决于服务器是能解密该报文为判定标准
  8. 服务器同样发送步骤6类似的报文。
  9. 服务器同样发送结束报文。
  10. 当服务器和客户端结束报文交换完成，则SSL连接建立。后续进行应用层传输。
  11. 应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性

> HTTPS 比 HTTP 要慢 2 到 100 倍
> SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢

### 确认访问用户身份的认证
- **HTTP/1.1 使用的认证方式**
  - BASIC 认证（基本认证）
  - DIGEST 认证（摘要认证）
  - SSL 客户端认证
  - FormBase 认证（基于表单认证）
### HTTP 的瓶颈
- 一条连接上只可发送一个请求。
- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
- 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多
- 可任意选择数据压缩格式。非强制压缩发送。

### web的攻击技术
- 跨站脚本攻击（XSS）
- SQL 注入攻击
- OS 命令注入攻击
- HTTP 首部注入攻击
- HTTP 响应截断攻击
- 邮件首部注入攻击
- 目录遍历攻击
- 远程文件包含漏洞
- 因设置或设计上的缺陷引发的安全漏洞
  - 强制浏览
  - 不正确的错误消息处理
  - 开放重定向
- 因会话管理疏忽引发的安全漏洞
  - 会话劫持
  - 会话固定攻击
  - 跨站点请求伪造（CSRF）
- 密码破解
- 点击劫持
- DoS 攻击