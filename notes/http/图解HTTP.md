### HTTP
什么是HTTP： HTTP（HyperText Transfer Protocol，超文本传输协议`(超文本转移协议)`）
### TCP/IP
>TCP/IP 是互联网相关的各类协议族的总称
- **TCP/IP 协议族按层次分别分为以下 4 层**：
  - 应用层、传输层、网络层和数据链路层
- 应用层
  - 应用层决定了向用户提供应用服务时通信的活动
  - TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP、DNS、HTTP
- 传输层
  - 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输
  - 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）
- 网络层（又名网络互连层）
  - 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位
  - 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线
- 链路层（又名数据链路层，网络接口层）
  - 用来处理连接网络的硬件部分。硬件上的范畴均在链路层的作用范围之内
- **TCP三次握手**
  - 用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达
  - 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和ACK（acknowledgement）（同步和确认标志）
    - 客户端首先发送一个带 SYN 标志的数据包给对方。
    - 服务端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。
    - 最后，客户端再回传一个带 ACK 标志的数据包，代表“握手”结束
- **TCP四次挥手**
  - 客户端发送FIN标记的数据包给服务端，请求断开连接
  - 服务端接收到FIN标记的数据包后，回传给ACK标记的包表示传达确认信息
  - 服务端再发送FIN标记的数据包给客户端，表示要断开连接
  - 接收到服务端FIN标记的数据包，客户端回传ACK标记的数据包表示确认。断开连接。
- **URI和URL**
   -  URI：统一资源标识符，URL：统一资源定位符；URL是URI的子集
   -  RFC标准：协议方案名://登录信息/服务器地址(ip/域名)/带层次的文件路径/查询字符串/片段标识符(#/,可选)
#### TCP为什么是三次握手，四次挥手
TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求。

握手握的是**通信双方数据原点的序列号**

要保证数据传输的可靠就**需要双方都确认收到了自己的序列号**。"三次握手"不多也不少，正好让双方明确彼此信息互通。
- A发送同步信号 `SYN + A的原点序列号` 给B
- B确认收到A的同步信号，记录为B的 ACK原点序列号
- B发送同步信号 `SYN + B的原点序列号` 给A
- A确认收到B的同步信号，记录为A的 ACK原点序列号

**2、3两步可以合为一步，只需3次握手，可以提高传输效率**

**如果为2次握手则B无法确认A是否已经收到的B的同步信号，传输也就不是可靠传输了。而4次握手对比3次带来的可靠性提示并不多。所以三次握手最为合适**

**TPC四次挥手原因**
- A发送FIN的信号给B
- B要确认A发送的FIN信号
- B再发送FIN给A
- A要确认B发送的FIN信号，B断开连接

**TCP即是可靠传输，所以断开时需要通信双方都确认断开。而FIN报文只有等其他报文发送完才能发送，不能一起发送，顾而挥手是四次。**

#### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态
因为在客户端接收到服务端的FIN包后，会发送ACK包给服务端，服务端接收到客户端的ACK包后，就知道客户端已经接收到了自己发出FIN包，之后会断开连接。但是客户端发送的ACK包有可能会丢失，当服务端在一定时间收不到客户端的ACK包，会重新发送FIN包给客户端。而对于客户端而言，当发送ACK包给服务端后，会等待一段时间，如果这段时间如果收到了来自服务端的FIN包，说明上次的ACK包丢失，客户端会重发ACK包给服务端。这段时间就是TIME_WAIT的时间。2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
### HTTP使用方法
- **GET** ：获取资源
- **POST**：传输实体主体
- **PUT**：传输文件
  - 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。
- **HEAD**：获得报文首部
  - HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。
- **DELETE**：删除文件
  - DELETE 方法用来删除文件，是与 PUT 相反的方法
- **OPTIONS**：询问支持的方法
- **TRACE**：追踪路径
  - 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输
  - TRACE 方法本来就不怎么常用，再加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。
- **CONNECT**：要求用隧道协议连接代理
  - CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。
### HTTP报文
- **HTTP报文构成**
  1. 请求行/响应行
     - 请求方法 URL HTTP版本(GET /index.html HTTP1.1)/ 响应转态吗 原因短语 HTTP版本(200 ok HTTP1.1)
  2. 请求头/响应头
     - 一般有4种首部（通用首部、请求首部、响应首部和实体首部）
  3. 请求实体/响应实体 → 也叫报文主体
- **报文主体和实体主体的差异**
  - 报文
    - 是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输
  - 实体
    - 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成
  - HTTP 报文的主体用于传输请求或响应的实体主体
  - 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异
- **压缩传输的内容编码**
  - 内容编码指明应用在实体内容上的编码格式
  - 常用的内容编码有：
    - gzip（GNU zip）
    - compress（UNIX 系统的标准压缩）
    - deflate（zlib）
    - identity（不进行编码
### 返回结果的 HTTP 状态码

|  |类别     |原因短语  |
|---------|---------|---------|
|1XX     |信息性状态码       |接收的请求正在处理       |
|2XX     |成功状态码         |请求正常处理完毕         |
|3XX     |重定向状态码       |需要进行附加操作以完成请求|
|4XX     |客户端错误状态码   |服务器无法处理请求        |
|5XX     |服务器错误状态码   | 服务器处理请求出错       |

- **常用的14种状态码**
  - 200 OK：表示从客户端发来的请求在服务器端被正常处理了
  - 204 No Content：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
  - 206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求
  - 301 Moved Permanently：永久性重定向
  - 302 Found：临时性重定向
  - 303 See Other：和 302 状态码有着相同的功能
    - 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源
    - 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别
    - >当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。
    - > 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做
  - 304 Not Modified：
    - 该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。
    - 304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。
    - >2 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部
    - > 这个一般指服务端缓存
  - 307 Temporary Redirect：临时重定向
    - 尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。
    - 307 会遵照浏览器标准，不会从 POST 变成 GET。
  - 400 Bad Request：表示请求报文中存在语法错误
  - 401 Unauthorized：表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息
    - 若之前已进行过 1 次请求，则表示用 户认证失败
  - 403 Forbidden：表明对请求资源的访问被服务器拒绝了
  - 404 Not Found：表明服务器上无法找到请求的资源
  - 500 Internal Server Error：表明服务器端在执行请求时发生了错误
  - 503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
### HTTP首部
**首部字段分四种：通用首部、请求首部、响应首部和实体首部**

- **通用首部字段**

|首部字段名          |说明  |
|-------------------|---------|
|Cache-Control      | 控制缓存的行为 |
|Connection         | 逐跳首部、连接的管理 |
|Date               | 创建报文的日期时间 |
|Pragma             | 报文指令 |
|Trailer            | 报文末端的首部一览 |
|Transfer-Encoding  | 指定报文主体的传输编码方式 |
|Upgrade            | 升级为其他协议 |
|Via                | 代理服务器的相关信息 |
|Warning            | 错误通知 |

- **请求首部字段**

|首部字段名  |说明  |
|---------------------|---------|
|Accept               | 用户代理可处理的媒体类型 |
|Accept-Charset       | 优先的字符集 |
|Accept-Encoding      | 优先的内容编码 |
|Accept-Language      | 优先的语言（自然语言） |
|Authorization        | Web认证信息 |
|Expect               | 期待服务器的特定行为 |
|From                 | 用户的电子邮箱地址 |
|Host                 | 请求资源所在服务器 |
|If-Match             | 比较实体标记（ETag） |
|If-Modified-Since    | 比较资源的更新时间 |
|If-None-Match        | 比较实体标记（与 If-Match 相反） |
|If-Range             | 资源未更新时发送实体 Byte 的范围请求 |
|If-Unmodified-Since  | 比较资源的更新时间（与If-Modified-Since相反） |
|Max-Forwards         | 最大传输逐跳数 |
|Proxy-Authorization  | 代理服务器要求客户端的认证信息 |
|Range                | 实体的字节范围请求 |
|Referer              | 对请求中 URI 的原始获取方 |
|TE                   | 传输编码的优先级 |
|User-Agent           | HTTP 客户端程序的信息 |

- **响应首部字段**

|首部字段名  |说明  |
|-------------------|---------|
|Accept-Ranges      | 是否接受字节范围请求|
|Age                | 推算资源创建经过时间 |
|ETag               | 资源的匹配信息 |
|Location           | 令客户端重定向至指定URI |
|Proxy-Authenticate | 代理服务器对客户端的认证信息 |
|Retry-After        | 对再次发起请求的时机要求 |
|Server             | HTTP服务器的安装信息 |
|Vary               | 代理服务器缓存的管理信息 |
|WWW-Authenticate   | 服务器对客户端的认证信息 |

- **实体首部字段**

|首部字段名  |说明  |
|-----------------|---------|
|Allow            | 资源可支持的HTTP方法 |
|Content-Encoding | 实体主体适用的编码方式 |
|Content-Language | 实体主体的自然语言 |
|Content-Length   | 实体主体的大小（单位：字节） |
|Content-Location | 替代对应资源的URI |
|Content-MD5      | 实体主体的报文摘要 |
|Content-Range    | 实体主体的位置范围 |
|Content-Type     | 实体主体的媒体类型 |
|Expires          | 实体主体过期的日期时间 |
|Last-Modified    | 资源的最后修改日期时间 |

------------------------------------- **Cache-Control** -------------------------------------
- **缓存请求指令**

|指令| 参数| 说明|
|---|------|-----|
|no-cache             | 无    | 强制向源服务器再次验证|
|no-store             | 无    | 不缓存请求或响应的任何内容|
|max-age = [ 秒]      | 必需   | 响应的最大Age值|
|max-stale( = [ 秒])  | 可省略 | 接收已过期的响应|
|min-fresh = [ 秒]    | 必需   | 期望在指定时间内的响应仍有效|
|no-transform         | 无    | 代理不可更改媒体类型|
|only-if-cached       | 无    | 从缓存获取资源|
|cache-extension      | -     | 新指令标记（token）|

- **缓存响应指令**

|指令 |参数| 说明|
|---|------|-----|
|public           | 无    | 可向任意方提供响应的缓存|
|private          | 可省略 | 仅向特定用户返回响应|
|no-cache         | 可省略 | 缓存前必须先确认其有效性|
|no-store         | 无    | 不缓存请求或响应的任何内容|
|no-transform     | 无    | 代理不可更改媒体类型|
|must-revalidate  | 无    | 可缓存但必须再向源服务器进行确认|
|proxy-revalidate | 无    |要求中间缓存服务器对缓存的响应有效性再进行确认|
|max-age = [ 秒]  | 必需   | 响应的最大Age值|
|s-maxage = [ 秒] | 必需   | 公共缓存服务器响应的最大Age值|
|cache-extension  | -     | 新指令标记（token）|

#### 缓存相关的指令和字段
- **no-cache** 指令： 防止从缓存中返回过期的资源。客户端将不会接收缓存过的响应。缓存服务器不能对资源进行缓存
- **no-store** 指令：no-store 才是真正地不进行缓存。
- **s-maxage** 指令：s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（代理），会忽略对 Expires 首部字段及max-age 指令的处理
- **max-age** 指令：判定缓存资源的缓存时间数值比指定时间的数值更小，说明缓存没有过期，那么客户端就接收缓存的资源。http 1.1 会忽略 Expires 首部字段。http1.0则相反。
- **min-fresh** 指令：要求缓存服务器返回至少还未过指定时间的缓存资源。
  - 比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。
- **max-stale** 指令：指示缓存资源，即使过期也照常接收。

**缓存字段**

- **If-Match**：只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求。反之，则返回状态码 412。
- **If-None-Match**：与 If-Match 首部字段的作用相反。只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与使用首部字段 If-Modified-Since 时有些类似。
- **If-Range**：它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。
- **If-Modified-Since**：如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求。返回状态码 304
- **If-Unmodified-Since**：和首部字段 If-Modified-Since 的作用相反。指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。发生了更新返回412

- **ETag**：首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。当资源更新时，ETag 值也需要更新。
  - 强 ETag 值，不论实体发生多么细微的变化都会改变其值。
  - 弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。

- **Expires**：首部字段 Expires 会将资源失效的日期告知客户端。
- **Last-Modified**：首部字段 Last-Modified 指明资源最终修改的时间。

#### 强缓存和协商缓存
- 强缓存也叫本地缓存，和协商缓存区别如下表

||获取资源形式|状态码|发送请求到服务器|
|-----|-----|-----|-----|
| 强缓存 | 从缓存获取 | 200 | 否，直接从缓存中取 |
| 协商缓存 | 从缓存获取 | 304 | 是，发送请求到服务器，由服务器决定是否使用缓存 |

- 设置强缓存：Expires和cache-control：max-age
- 设置协商缓存：
  - Last-Modified和If-Modified-Since
  - Etag和If-None-Match

- 有Last-Modified为什么还要Etag
  - Etag 主要为了解决 Last-Modified 无法解决的一些问题
    1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET
    2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
    3. 某些服务器不能精确的得到文件的最后修改时间

> Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应

### 确保web安全的HTTPS
- **HTTP的缺点**
  - HTTP是明文传输，内容容易被窃取。
  - HTTP无法进行身份认证，容易被伪装
  - HTTP不能确认报文的完整性，不能判断报文是否被串改
- **什么是HTTPS**
  - 就是HTTP+加密+认证+完整性保护。
  - HTTPS是身披SSL外壳的HTTP。
- **HTTPS采用的是混合加密模式**
  - 数据传输使用的共享秘钥加密（对称加密），传输对称加密共享秘钥时使用的是公开秘钥加密（非对称加密）
  - 因为非对称加密比对称加密处理要更为复杂，处理速度要慢所以在保证安全的前提下使用对称加密传输数据
  - 由于要证明公开秘钥本身是可信任，货真价实的秘钥，所以引入了数字证书认证机构
- **数字证书认证机构的业务流程**
  - 首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起
  - 服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书
  - 接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的
  - 考虑到公开秘钥传输的安全性，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。
- **HTTPS 的安全通信机制**
  1. 客户端通过发送报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件列表
  2. 服务器可进行 SSL 通信时，服务端会根据客户端的加密组件类表，以及本身支持的加密列表筛选出共同支持的加密组件列表发送至客户端
  3. 之后服务端会发送包含公开秘钥证书的报文
  4. 最后服务器通知客户端SSL协商结束
  5. SSL协商结束后，客户端会使用公开秘钥证书中的公开秘钥对服务器进行验证，验证通过后，会使用公开秘钥加密对称加密生成的共享秘钥，最后把加密的共享秘钥已经经过对称加密的报文发送给服务端。
  6. 之后会在发送报文，提示服务器以后通信用这个共享秘钥
  7. 客户端发送结束报文。此次握手协商是否成功，要取决于服务器是能解密该报文为判定标准
  8. 服务器同样发送步骤6类似的报文。
  9. 服务器同样发送结束报文。
  10. 当服务器和客户端结束报文交换完成，则SSL连接建立。后续进行应用层传输。
  11. 应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性

> HTTPS 比 HTTP 要慢 2 到 100 倍
> SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢

### 确认访问用户身份的认证
- **HTTP/1.1 使用的认证方式**
  - BASIC 认证（基本认证）
  - DIGEST 认证（摘要认证）
  - SSL 客户端认证
  - FormBase 认证（基于表单认证）
### HTTP 的瓶颈
- 一条连接上只可发送一个请求。
- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
- 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多
- 可任意选择数据压缩格式。非强制压缩发送。

### web的攻击技术
- 跨站脚本攻击（XSS）
- SQL 注入攻击
- OS 命令注入攻击
- HTTP 首部注入攻击
- HTTP 响应截断攻击
- 邮件首部注入攻击
- 目录遍历攻击
- 远程文件包含漏洞
- 因设置或设计上的缺陷引发的安全漏洞
  - 强制浏览
  - 不正确的错误消息处理
  - 开放重定向
- 因会话管理疏忽引发的安全漏洞
  - 会话劫持
  - 会话固定攻击
  - 跨站点请求伪造（CSRF）
- 密码破解
- 点击劫持
- DoS 攻击