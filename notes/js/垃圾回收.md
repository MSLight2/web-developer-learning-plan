## JS垃圾回收

垃圾数据回收分为`手动回收`和`自动回收`两种策略

**JavaScript**采用的是`自动回收`策略

因为`JavaScript`数据是存储在栈和堆两种内存空间中的，所以我们就来看看JavaScript“**栈中的垃圾数据**”和“**堆中的垃圾数据**”是如何回收

### 栈中的垃圾数据
当一个函数执行时，会压入调用栈，与此同时，**还有一个记录当前执行状态的指针（称为 ESP）**。当这个函数执行结束之后，则需要销毁这个函数的执行上下文。ESP指针则会下移到上个上下文，**这个下移操作就是销毁 showName 函数执行上下文的过程**。

上一个函数执行上下文虽然在栈内存中，但是已经是无效内存了，当再次调用函数时，这块内存会被直接覆盖掉，用来存放另外一个函数的执行上下文。

**所以当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**

### 堆中的垃圾数据
#### 代际假说和分代收集
代际假说有以下两个特点：
  - 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
  - 第二个是不死的对象，会活得更久。

在 V8 中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。
  - **副垃圾回收器，主要负责新生代的垃圾回收**。
  - **主垃圾回收器，主要负责老生代的垃圾回收**。

不论什么类型的垃圾回收器，它们都有一套共同的执行流程
  - 第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
  - 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
  - 第三步是做内存整理。（整理内存碎片）

##### 副垃圾回收器
副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，**一半是对象区域**，**一半是空闲区域**。

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。之后将存活的对象复制到空闲区，**再将对象区域与空闲区域进行角色翻转。复制过程也是对象的整理过程**。

由于新生区的空间不大，内存容易满，JavaScript 引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

##### 主垃圾回收器
老生区中的对象有两个特点，**一个是对象占用空间大**，**另一个是对象存活时间长**。

主垃圾回收器是采用**标记 - 清除（Mark-Sweep）**的算法进行垃圾回收的。清楚后进行另外一种算法——**标记 - 整理（Mark-Compact）**

**全停顿：**

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。
