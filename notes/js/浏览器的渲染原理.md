### Chrome浏览器开启一个页面为什么有4个进程
- 进程和线程的关系
  - 线程是不能单独存在的，它是由进程来启动和管理的
  - 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫`进程`
  - 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率
  - 进程和线程之间的关系有以下 4 个特点
    1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
    2. 线程之间共享进程中的数据
    3. 当一个进程关闭之后，操作系统会回收进程所占用的内存
    4. 进程之间的内容相互隔离（如果进程之间需要进行数据的通信，就需要使用用于进程间通信（IPC）的机制）

#### 单进程浏览器时代

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里

存在问题：
  - 不稳定
  - 不流畅
  - 不安全

#### 多进程浏览器时代

多进程很好的解决了单进程不稳定和不流畅的问题，同时通过`安全沙箱`解决了浏览器不安全的问题。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限

**最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程**

- `浏览器进程`: 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
- `渲染进程`: 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下
- `CPU进程`: 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程
- `网路进程`: 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
- `插件进程`: 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

多进程造成的问题：`更高的资源占用`和`更复杂的体系架构`

未来：`面向服务的架构(SOA)`

- 单进程浏览器当时不可以采用安全沙箱？
  - 如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的
- iframe会创建多少个渲染进程
  - 一个iframe会创建一个渲染进程，`相同域名公共一个渲染进程`，tab标签也是如此；如果有多个iframe标签，且域名不同则会创建多个渲染标签
- Chrome输出的界面书图片为什么又可以选中文字等？
  - 点击鼠标选中文字的时候，这些消息会传递到渲染进程，渲染进程再合成选中文字的状态，然后更新图片！

### Chrome浏览器的渲染流程
#### 浏览器发起HTTP请求流程
构建请求（请求行）→ 查找缓存 → 准备IP地址和端口（DNS解析、缓存，HTTPS还需建立TLS链接） → 等待TCP队列（同一域名对多6个TCP连接） → 建立TCP连接 → 发送请求 → 服务器返回请求结果 → 断开连接（`Connection:Keep-Alive`不会断开）

`301`: **重定向** （`curl -I www.xxx.com` 查看；`-I`表示只需要获取响应头和响应行数据，而不需要获取响应体的数据）

浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源；但如果缓存过期了，浏览器则会继续发起网络请求，并且在 **HTTP 请求头**中带上`If-None-Match:"4f80f-XXXXXXXX"`，服务器收到请求头后，会根据 `If-None-Match` 的值来判断请求的资源是否有更新。没更新返回`304`：表名浏览器可以继续使用缓存，有则直接返回新资源

网络问题分析：

1. 首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过ping curl看看对应的时延高不高。

2. 然后通过wireshake看看具体哪里出了问题。

#### 在浏览器里，从输入 URL 到页面展示，这中间发生了什么
1. 用户输入url并回车
2. 浏览器进程检查url，组装协议，构成完整的url
3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
5. 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
    5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
    5.2 利用ip地址和服务器建立tcp连接
    5.3 构建请求头信息
    5.4 发送请求头信息
    5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
6. 网络进程解析响应流程；
    6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步
        （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    6.2 200响应处理：
        检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
        后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
7. 准备渲染进程
    7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
8. 传输数据、更新状态
    8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
    8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。此时的web页是空白页。
10. 文档提交后，渲染进程就开始进入渲染流程以及资源的加载。HTML通过解析器将HTML解析成DOM Tree，CSS通过CSS规则和CSS解释器转成CSS Tree(将CSS文本转换成`styleSheet`)，通过DOM Tree和CSS Tree计算出DOM 元素的布局信息，保存在布局数中（合成render Tree）。通过布局数算出元素具体的宽高颜色位置，在经过`图层`、`绘制`、`光栅化`、`合成`最后显示出来。

> noopener noreferrer 不共享页面内容，开启新的渲染进程（可以防止一些钓鱼网站窃取父窗口的信息）

### DOM的渲染
#### 渲染流水线
流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成

- 开始每个子阶段都有其**输入的内容**
- 然后每个子阶段有其**处理过程**
- 最终每个子阶段会生成**输出内容**

#### 流水线
- 构建 DOM 树
  - 因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
- 样式计算
  - 把 CSS 转换为浏览器能够理解的结构：当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets（document.styleSheets）
  - 转换样式表中的属性值，使其标准化
  - 计算出 DOM 树中每个节点的具体样式
- 布局阶段
  - 创建布局树：在显示之前，我们还要额外地构建一棵只包含可见元素布局树
  - 布局计算
- 分层
  - 因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树**
  - 需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？
    - 第一点，拥有层叠上下文属性的元素会被提升为单独的一层。
    - 第二点，需要剪裁（clip）的地方也会被创建为图层
- 图层绘制
- 栅格化（raster）操作
  - 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图
  - 通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。
- 合成和显示

#### 总结：

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

#### “重排”“重绘”和“合成”
- 你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫**重排**。无疑，**重排需要更新完整的渲染流水线，所以开销也是最大的**。
- 更新元素的绘制属性（重绘）：重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
- 渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成；相对于重绘和重排，合成能大大提升绘制效率。

## JavaScript执行机制
## v8工作原理
## 页面循环系统（event loop）
## 浏览器网络
## 浏览器安全
