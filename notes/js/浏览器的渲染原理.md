### Chrome浏览器开启一个页面为什么有4个进程
- 进程和线程的关系
  - 线程是不能单独存在的，它是由进程来启动和管理的
  - 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫`进程`
  - 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率
  - 进程和线程之间的关系有以下 4 个特点
    1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
    2. 线程之间共享进程中的数据
    3. 当一个进程关闭之后，操作系统会回收进程所占用的内存
    4. 进程之间的内容相互隔离（如果进程之间需要进行数据的通信，就需要使用用于进程间通信（IPC）的机制）

#### 单进程浏览器时代

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里

存在问题：
  - 不稳定
  - 不流畅
  - 不安全

#### 多进程浏览器时代

多进程很好的解决了单进程不稳定和不流畅的问题，同时通过`安全沙箱`解决了浏览器不安全的问题。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限

**最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程**

- `浏览器进程`: 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
- `渲染进程`: 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下
- `CPU进程`: 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程
- `网路进程`: 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
- `插件进程`: 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

多进程造成的问题：`更高的资源占用`和`更复杂的体系架构`

未来：`面向服务的架构(SOA)`

- 单进程浏览器当时不可以采用安全沙箱？
  - 如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的
- iframe会创建多少个渲染进程
  - 一个iframe会创建一个渲染进程，`相同域名公共一个渲染进程`，tab标签也是如此；如果有多个iframe标签，且域名不同则会创建多个渲染标签
- Chrome输出的界面书图片为什么又可以选中文字等？
  - 点击鼠标选中文字的时候，这些消息会传递到渲染进程，渲染进程再合成选中文字的状态，然后更新图片！

### Chrome浏览器的渲染流程
#### 浏览器发起HTTP请求流程
构建请求（请求行）→ 查找缓存 → 准备IP地址和端口（DNS解析、缓存，HTTPS还需建立TLS链接） → 等待TCP队列（同一域名对多6个TCP连接） → 建立TCP连接 → 发送请求 → 服务器返回请求结果 → 断开连接（`Connection:Keep-Alive`不会断开）

`301`: **重定向** （`curl -I www.xxx.com` 查看；`-I`表示只需要获取响应头和响应行数据，而不需要获取响应体的数据）

浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源；但如果缓存过期了，浏览器则会继续发起网络请求，并且在 **HTTP 请求头**中带上`If-None-Match:"4f80f-XXXXXXXX"`，服务器收到请求头后，会根据 `If-None-Match` 的值来判断请求的资源是否有更新。没更新返回`304`：表名浏览器可以继续使用缓存，有则直接返回新资源

#### 在浏览器里，从输入 URL 到页面展示，这中间发生了什么
1. 处理用户输入：如果用户输入的是搜索内容并，则调用浏览器默认搜索引擎搜索。如果是符合规则的URL，则会合成完整的URL。
2. 浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。
3. 首先网络进程会构建HTTP请求行，然后浏览器会在本地查找是否有缓存，有则拦截请求，返回缓存资源；如果没有则继续网络请求流程
4. 网络进程请求DNS（DNS查询）返回IP地址和端口号。如果是HTTPS请求还会建立TLS连接。
5. 通过IP地址、端口号和服务器建立TCP连接。（在Chrome中，一次最多发送6个请求。超过请求数的请求进入排队等待状态。） TCP连接后，网路进程会构建HTTP请求头信息，将数据包发送给服务器。服务器处理请求，返回结果。
6. 网络进程解析响应数据包。如果响应结果是重定向则会重新发送HTTP请求；如果响应头中`Content-Type`类型是字节流，则导航结束，请求会交给浏览器的下载管理器；如果响应类型是HTML则通知浏览器进程准备渲染
7. 当浏览器进程接到通知，会开始准备渲染进程；浏览器进程会判断当前url是否和之前打开的渲染进程根域名是否相同，相同则复用之前的渲染进程，不同则开启新的渲染进程。
8. 渲染进程准备好后，浏览器会发出"**提交文档**"的消息给渲染进程，当渲染进程接收"**提交文档**"的消息后会和网络进程建立传输数据的"**管道**"，当数据传输完成后，渲染进程会向浏览器进程发送"**确认提交**"的消息
9.  浏览器进程接收到"**确认提交**"的消息后会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。此时的web页是空白页。
10. 文档提交后，渲染进程就开始进入渲染流程以及资源的加载。HTML通过解析器将HTML解析成DOM Tree，CSS通过CSS规则和CSS解释器转成CSS Tree(将CSS文本转换成`styleSheet`)，通过DOM Tree和CSS Tree计算出DOM 元素的布局信息，保存在布局数中（合成render Tree）。通过布局数算出元素具体的宽高颜色位置，在经过`图层`、`绘制`、`光栅化`、`合成`最后显示出来。

> noopener noreferrer 不共享页面内容，开启新的渲染进程（可以防止一些钓鱼网站窃取父窗口的信息）
